import { t } from "structural";
import path from "path";
import fs from "fs/promises";
import json5 from "json5";
import create from "../../source/tools/tool-defs/create";
import { fileURLToPath } from "url";
import { fixJsonPrompt } from "../../source/autofix-prompts";
import { genDiffs } from "../generate-edits";
import { cutIndex, insertAt } from "../str";
import { pickRandom } from "../random";
import { tryexpr } from "../../source/tryexpr";
const __dirname = path.dirname(fileURLToPath(import.meta.url));

const TRAIN_PATH = path.join(__dirname, "unfat/output/data/train.jsonl");
const EVAL_PATH = path.join(__dirname, "unfat/output/data/eval.jsonl");
const MAX_NUM_BREAKS = 4;
const DIFF_GEN_PERCENT = 0.02;
const EVAL_PERCENT = 0.2;
const NOT_JSON_PERCENT = 0.1;
const JSON5_PERCENT = 0.01;
const NEST_PERCENT = 0.05;
const MAX_NESTING = 5;

const REPOS_DIR = path.join(path.dirname(__dirname), "repos");

async function main() {
  try {
    await fs.rm(TRAIN_PATH);
    await fs.rm(EVAL_PATH);
  } catch {}
  await fs.mkdir(path.dirname(TRAIN_PATH), { recursive: true });
  await fs.writeFile(TRAIN_PATH, "");
  await fs.writeFile(EVAL_PATH, "");

  const pokedex = JSON.parse(await fs.readFile(
    path.join(__dirname, "json-repos/pokedex/pokedex.json"),
    "utf8"
  ));
  await genBrokenJsonFromArray("Pokedex", pokedex["pokemon"]);

  const reps = JSON.parse(await fs.readFile(
    path.join(__dirname, "json-repos/us-representatives.json"),
    "utf8",
  ));
  await genBrokenJsonFromArray("US Representatives", reps["objects"]);

  const reddit = await fs.readdir(path.join(__dirname, "json-repos/reddit"));
  for(const redditJson of reddit) {
    const parsed = JSON.parse(await fs.readFile(
      path.join(__dirname, "json-repos/reddit", redditJson),
      "utf8",
    ));
    await genBrokenJsonFromArray(`/r/${redditJson}`, parsed["data"]["children"]);
  }

  const movies2010 = JSON.parse(await fs.readFile(
    path.join(__dirname, "json-repos/wikipedia-movie-data/movies-2010s.json"),
    "utf8",
  ));
  await genBrokenJsonFromArray("Movies (2010s)", movies2010);

  const movies2020 = JSON.parse(await fs.readFile(
    path.join(__dirname, "json-repos/wikipedia-movie-data/movies-2020s.json"),
    "utf8",
  ));
  await genBrokenJsonFromArray("Movies (2020s)", movies2020);

  const repos = await fs.readdir(REPOS_DIR);
  for(const repo of repos) {
    console.log("Generating broken JSON for", repo);
    await genBrokenJsonForRepo(path.join(REPOS_DIR, repo));
  }
}

async function genBrokenJsonFromArray(name: string, array: any[]) {
  let count = 0;
  for await(const obj of array) {
    count++;
    const sample = randomlyBreak(JSON.stringify(obj));
    const outputPath = Math.random() > EVAL_PERCENT ? TRAIN_PATH : EVAL_PATH;
    const messages = [
      {
        role: "user",
        content: fixJsonPrompt(sample.input),
      },
      {
        role: "assistant",
        content: sample.groundTruth,
      },
    ];
    await fs.appendFile(outputPath, JSON.stringify({
      messages
    }) + "\n", "utf8");
  }
  console.log(`Generated ${count} samples for`, name);
}

async function genBrokenJsonForRepo(path: string) {
  let count = 0;
  for await(const sample of getSamplesForRepo(path)) {
    count++;
    const outputPath = Math.random() > EVAL_PERCENT ? TRAIN_PATH : EVAL_PATH;
    const messages = [
      {
        role: "user",
        content: fixJsonPrompt(sample.input),
      },
      {
        role: "assistant",
        content: sample.groundTruth,
      },
    ];
    await fs.appendFile(outputPath, JSON.stringify({
      messages
    }) + "\n", "utf8");
  }
  console.log(`Generated ${count} samples for`, path);
}

type Sample = {
  input: string,
  groundTruth: string,
};

async function* getSamplesForRepo(dirpath: string): AsyncGenerator<Sample> {
  for await(const diff of genDiffs(path.join(dirpath, ".git"))) {
    if(Math.random() > DIFF_GEN_PERCENT) continue;
    yield randomlyBreak(JSON.stringify(diff));
  }

  for await(const sourceFile of getSourceFiles(dirpath)) {
    const file = await fs.readFile(sourceFile, "utf8");
    const [ err, _ ] = tryexpr(() => JSON.parse(file));

    if(err == null) {
      yield randomlyBreak(file);
      continue;
    }

    if(Math.random() > NOT_JSON_PERCENT) {
      yield {
        input: file,
        groundTruth: JSON.stringify({ success: false }),
      };
      continue;
    }

    const createEdit: t.GetType<typeof create.ArgumentsSchema> = {
      filePath: sourceFile,
      content: file,
    };
    yield randomlyBreak(JSON.stringify(createEdit));
  }
}

// Random keys to use for nesting, generated by Kimi K2
const keyNamePool: string[] = [
  'accentHue', 'accountHandle', 'aetherToken', 'aliasHash', 'altitude', 'apiRev', 'asymKeyTag',
  'auditEpoch', 'axisX', 'badgeUri', 'baseTimeIso', 'bearingDeg', 'binaryFmt', 'birthSecond',
  'blinker', 'blurbHtml', 'bounceMs', 'burrow', 'caThumb', 'cadenceMs', 'captionMd', 'catchphrase',
  'censusTract', 'centroidLat', 'chakraIndex', 'charterDate', 'chorusId', 'cipherNonce', 'civicId',
  'clerkCode', 'clickDepth', 'clipboardSig', 'codec', 'colorway', 'crewName', 'deltaUs',
  'deltaWing', 'deniableKey', 'depthFt', 'detailYaml', 'deviceUuid', 'dripTheme', 'driver',
  'dwellSec', 'elevationEofe', 'emblemSvg', 'entityTag', 'ephemSeed', 'epochNonce', 'etherFlick',
  'errCount', 'excerptTxt', 'favoriteLocale', 'flagsBitset', 'flareIndex', 'flashNonce', 'fluxCap',
  'forename', 'forkBcrypt', 'franchiseTag', 'freezeSec', 'fuzzyHash', 'gamePreset', 'genesisEpoch',
  'geoCell', 'glancePct', 'glitchAura', 'glitchSpan', 'gpgArmor', 'hash512', 'headline',
  'hearthTone', 'hemisphere', 'hypeScore', 'hushSeed', 'iconPack', 'identityNonce', 'imprint',
  'infuseRatio', 'intensityF', 'intlLocale', 'ivSeed', 'jiffyStamp', 'jinxCode', 'jitterCap',
  'jitterUs', 'jointKey', 'journeyId', 'jweToken', 'karmaDelta', 'kernelVer', 'keySlot',
  'kickoffEpoch', 'kickerLine', 'kitStyle', 'kudosToken', 'ledgerJson', 'legacyMask',
  'lifecyclePhase', 'lineageToken', 'lithiumMark', 'localOffset', 'longitude', 'loreRoot',
  'loungedId', 'luminance', 'luminosityMax', 'lureVal', 'luminaTheme', 'macHmac', 'mapChunk',
  'memoRaw', 'memorabilia', 'mercatorTile', 'metaHint', 'mglCoords', 'millisecondOffset',
  'mimeType', 'mintimeFlag', 'mirrorSig', 'mirthSeed', 'missionStack', 'modIndex', 'moduleVer',
  'monikerSlug', 'moonEpoch', 'morphTag', 'motifId', 'neonHex', 'nilScore', 'nirvanaTick', 'norm',
  'northing', 'notaryCode', 'notesField', 'nthElement', 'nullBits', 'oblivionSalt', 'offsetTick',
  'omenTick', 'oracleRank', 'orionKey', 'overture', 'pageRank', 'pagerankNorm', 'paletteTweak',
  'paradigmFlag', 'parableCbor', 'paramsDict', 'parsecOffset', 'passphraseHint', 'perigeeKm',
  'personaSketch', 'pinOffset', 'pingJitter', 'pipelineVer', 'planetaryDay', 'polygon', 'portalId',
  'postcard', 'powerPct', 'praxisId', 'precessSpan', 'presetBlob', 'prngSeed', 'profileDossier',
  'pulseArc', 'pulverizeMs', 'queriedTs', 'queryLoad', 'queueDepth', 'quiltId', 'quirx',
  'quotation', 'quipBlurb', 'radianSnap', 'radiusKm', 'ramTrack', 'randomNonce', 'rank',
  'rateLimit', 'realmAlias', 'regionBucket', 'regretIndex', 'remarkXml', 'renderNs', 'retroSkin',
  'rewindCursor', 'ringToken', 'riotKey', 'rockKey', 'romanCode', 'rotationSnap', 'radiusKm',
  'ruinList', 'saltSprinkle', 'schemaUri', 'scoreVector', 'scrubIndex', 'sectorId', 'sessionKey',
  'shredRounds', 'sidebar', 'signetCode', 'slangString', 'sliceId', 'softHash', 'soilId',
  'sparkNonce', 'spec', 'splashUri', 'springOffset', 'starSign', 'stateNonce', 'staticHash',
  'streetQuad', 'subEpoch', 'substanceTag', 'suffix', 'surnameStem', 'tag64', 'taglineVerse',
  'tarpId', 'tasTick', 'tasteRating', 'teaserTxt', 'temporalChecksum', 'tessera', 'textureId',
  'tin', 'tint', 'tokenNonce', 'topologyHash', 'touchHeatmap', 'traceId', 'tractPoly',
  'treasureMap', 'tribeId', 'trickle', 'trinityHash', 'troveKey', 'tuningFork', 'twilightMs',
  'twirlFactor', 'twixtHash', 'txHash', 'type', 'uniqueHits', 'uniqueId', 'unitMask', 'updateVer',
  'upgradeSlot', 'uptimeNs', 'urmId', 'urmCode', 'urn', 'usageScore', 'usecaseTags', 'uterms',
  'utmZone', 'uvegaMetric', 'uvPattern', 'vaultIndex', 'vectorAngle', 'vegaPoint', 'verbatimText',
  'vergeId', 'vibeYaml', 'victoryStamp', 'vin', 'vip', 'virtueId', 'visualHash', 'vividKey',
  'voidIndex', 'voxelKey', 'waiverNonce', 'wavelet', 'whiffRate', 'widgetBlob', 'wielderId',
  'wildNonce', 'windchime', 'wingSpan', 'workgroup', 'worldChunk', 'wombatKey', 'xenoMask',
  'xFactor', 'xmlSig', 'xrayHash', 'yawlId', 'yearbookId', 'yieldFlag', 'yokeCode', 'yumSalt',
  'zapsLeft', 'zeroMark', 'zilchFlag', 'zodiacTag', 'zoomLevel', 'zorroSig', 'zyxKey'
];

function randomlyBreak(str: string): Sample {
  if(Math.random() > JSON5_PERCENT) {
    return {
      input: json5.stringify(str),
      groundTruth: JSON.stringify({ success: true, json: JSON.parse(str) }),
    }
  }
  let original = str;

  if(Math.random() > NEST_PERCENT) {
    const nestcount = Math.floor(Math.random() * MAX_NESTING);
    for(let i = 0; i < nestcount; i++) {
      const key = pickRandom(keyNamePool);
      original = JSON.stringify({ [key]: original });
    }
  }

  let broken = original;
  const breaker = pickRandom(breakFns);
  const breaks = Math.floor(Math.random() * MAX_NUM_BREAKS);
  for(let i = 0; i < breaks; i++) {
    broken = breaker(broken);
  }

  const [ err ] = tryexpr(() => JSON.parse(broken));
  if(err == null) return randomlyBreak(str);

  return {
    input: broken,
    groundTruth: JSON.stringify({ success: true, json: JSON.parse(original) }),
  };
}

const breakFns: Array<(search: string) => string> = [];
function defineBreak(cb: (search: string) => string) {
  breakFns.push(cb);
}

defineBreak(str => {
  const indexes = findEscaped(str, [ "n", '"' ]);
  return cutIndex(str, pickRandom(indexes));
});
defineBreak(str => {
  const indexes = findUnescaped(str, [ "{", "}", ",", '"', ":" ]);
  return cutIndex(str, pickRandom(indexes));
});
defineBreak(str => {
  const indexes = findUnescaped(str, [ '"', "}" ]);
  return insertAt(str, pickRandom(indexes) - 1, "\\");
});

function findJsonIndexes(source: string, escaped: boolean, strings: string[]) {
  const search = new Set(strings);
  let isEscaped = false;
  const indexes: number[] = [];

  for(let i = 0; i < source.length; i++) {
    const char = source[i];
    if(char === "\\") isEscaped = !isEscaped;
    if(search.has(char) && escaped === isEscaped) indexes.push(i);
    if(char !== "\\") isEscaped = false;
  }

  return indexes;
}

function findEscaped(source: string, strings: string[]) {
  return findJsonIndexes(source, true, strings);
}
function findUnescaped(source: string, strings: string[]) {
  return findJsonIndexes(source, false, strings);
}

const SOURCE_FILE_EXTS = new Set([
  "js", "css", "ts", "jsx", "tsx", "rb", "py", "rs", "c", "cpp", "h", "toml", "md", "yml", "yaml",
  "ini", "pylintrc", "txt", "rst", "rspec", "jshintrc", "prettierignore", "npmrc", "spec",
  "gitignore", "yardopts", "simplecov", "gemspec", "in", "nix", "lua",
]);
const SPECIAL_SOURCE_FILES = new Set([
  "Gemfile", "Rakefile", "CODEOWNERS", "AUTHORS", "LICENSE", "OWNERS", "release-notes",
]);

async function* getSourceFiles(dirpath: string) {
  const direntries = await fs.readdir(dirpath);
  for(const entry of direntries) {
    const fullpath = path.join(dirpath, entry);
    const stat = await fs.stat(fullpath);
    if(stat.isFile()) {
      if(SPECIAL_SOURCE_FILES.has(entry)) yield fullpath;
      if(entry.includes(".")) {
        const pieces = entry.split(".");
        const ext = pieces[pieces.length - 1];
        if(SOURCE_FILE_EXTS.has(ext)) {
          yield fullpath;
        }
      }
    }
    else if(stat.isDirectory()) {
      if(entry[0] !== ".") yield* await getSourceFiles(fullpath);
    }
  }
}

main();
